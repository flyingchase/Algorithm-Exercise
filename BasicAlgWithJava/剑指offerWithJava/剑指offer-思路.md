# 剑指offer-思路

## 数组与矩阵

- [3. 数组中重复的数字](http://www.cyc2018.xyz/算法/剑指 Offer 题解/3. 数组中重复的数字.html)
- [4. 二维数组中的查找](http://www.cyc2018.xyz/算法/剑指 Offer 题解/4. 二维数组中的查找.html)
- [5. 替换空格](http://www.cyc2018.xyz/算法/剑指 Offer 题解/5. 替换空格.html)
- [29. 顺时针打印矩阵](http://www.cyc2018.xyz/算法/剑指 Offer 题解/29. 顺时针打印矩阵.html)
- [50. 第一个只出现一次的字符位置](http://www.cyc2018.xyz/算法/剑指 Offer 题解/50. 第一个只出现一次的字符位置.html)

## [#](http://www.cyc2018.xyz/算法/剑指 Offer 题解/剑指 Offer 题解 - 目录.html#栈队列堆)栈队列堆

- [9. 用两个栈实现队列](http://www.cyc2018.xyz/算法/剑指 Offer 题解/9. 用两个栈实现队列.html)
- [30. 包含 min 函数的栈](http://www.cyc2018.xyz/算法/剑指 Offer 题解/30. 包含 min 函数的栈.html)
- [31. 栈的压入、弹出序列](http://www.cyc2018.xyz/算法/剑指 Offer 题解/31. 栈的压入、弹出序列.html)
- [40. 最小的 K 个数](http://www.cyc2018.xyz/算法/剑指 Offer 题解/40. 最小的 K 个数.html)
- [41.1 数据流中的中位数](http://www.cyc2018.xyz/算法/剑指 Offer 题解/41.1 数据流中的中位数.html)
- [41.2 字符流中第一个不重复的字符](http://www.cyc2018.xyz/算法/剑指 Offer 题解/41.2 字符流中第一个不重复的字符.html)
- [59. 滑动窗口的最大值](http://www.cyc2018.xyz/算法/剑指 Offer 题解/59. 滑动窗口的最大值.html)

## [#](http://www.cyc2018.xyz/算法/剑指 Offer 题解/剑指 Offer 题解 - 目录.html#双指针)双指针

- [57.1 和为 S 的两个数字](http://www.cyc2018.xyz/算法/剑指 Offer 题解/57.1 和为 S 的两个数字.html)
- [57.2 和为 S 的连续正数序列](http://www.cyc2018.xyz/算法/剑指 Offer 题解/57.2 和为 S 的连续正数序列.html)
- [58.1 翻转单词顺序列](http://www.cyc2018.xyz/算法/剑指 Offer 题解/58.1 翻转单词顺序列.html)
- [58.2 左旋转字符串](http://www.cyc2018.xyz/算法/剑指 Offer 题解/58.2 左旋转字符串.html)

## [#](http://www.cyc2018.xyz/算法/剑指 Offer 题解/剑指 Offer 题解 - 目录.html#链表)链表

- [6. 从尾到头打印链表](http://www.cyc2018.xyz/算法/剑指 Offer 题解/6. 从尾到头打印链表.html)
- [18.1 在 O(1) 时间内删除链表节点](http://www.cyc2018.xyz/算法/剑指 Offer 题解/18.1 在 O(1) 时间内删除链表节点.html)
- [18.2 删除链表中重复的结点](http://www.cyc2018.xyz/算法/剑指 Offer 题解/18.2 删除链表中重复的结点.html)
- [22. 链表中倒数第 K 个结点](http://www.cyc2018.xyz/算法/剑指 Offer 题解/22. 链表中倒数第 K 个结点.html)
- [23. 链表中环的入口结点](http://www.cyc2018.xyz/算法/剑指 Offer 题解/23. 链表中环的入口结点.html)
- [24. 反转链表](http://www.cyc2018.xyz/算法/剑指 Offer 题解/24. 反转链表.html)
- [25. 合并两个排序的链表](http://www.cyc2018.xyz/算法/剑指 Offer 题解/25. 合并两个排序的链表.html)
- [35. 复杂链表的复制](http://www.cyc2018.xyz/算法/剑指 Offer 题解/35. 复杂链表的复制.html)
- [52. 两个链表的第一个公共结点](http://www.cyc2018.xyz/算法/剑指 Offer 题解/52. 两个链表的第一个公共结点.html)

## [#](http://www.cyc2018.xyz/算法/剑指 Offer 题解/剑指 Offer 题解 - 目录.html#树)树

- [7. 重建二叉树](http://www.cyc2018.xyz/算法/剑指 Offer 题解/7. 重建二叉树.html)
- [8. 二叉树的下一个结点](http://www.cyc2018.xyz/算法/剑指 Offer 题解/8. 二叉树的下一个结点.html)
- [26. 树的子结构](http://www.cyc2018.xyz/算法/剑指 Offer 题解/26. 树的子结构.html)
- [27. 二叉树的镜像](http://www.cyc2018.xyz/算法/剑指 Offer 题解/27. 二叉树的镜像.html)
- [28. 对称的二叉树](http://www.cyc2018.xyz/算法/剑指 Offer 题解/28. 对称的二叉树.html)
- [32.1 从上往下打印二叉树](http://www.cyc2018.xyz/算法/剑指 Offer 题解/32.1 从上往下打印二叉树.html)
- [32.2 把二叉树打印成多行](http://www.cyc2018.xyz/算法/剑指 Offer 题解/32.2 把二叉树打印成多行.html)
- [32.3 按之字形顺序打印二叉树](http://www.cyc2018.xyz/算法/剑指 Offer 题解/32.3 按之字形顺序打印二叉树.html)
- [33. 二叉搜索树的后序遍历序列](http://www.cyc2018.xyz/算法/剑指 Offer 题解/33. 二叉搜索树的后序遍历序列.html)
- [34. 二叉树中和为某一值的路径](http://www.cyc2018.xyz/算法/剑指 Offer 题解/34. 二叉树中和为某一值的路径.html)
- [36. 二叉搜索树与双向链表](http://www.cyc2018.xyz/算法/剑指 Offer 题解/36. 二叉搜索树与双向链表.html)
- [37. 序列化二叉树](http://www.cyc2018.xyz/算法/剑指 Offer 题解/37. 序列化二叉树.html)
- [54. 二叉查找树的第 K 个结点](http://www.cyc2018.xyz/算法/剑指 Offer 题解/54. 二叉查找树的第 K 个结点.html)
- [55.1 二叉树的深度](http://www.cyc2018.xyz/算法/剑指 Offer 题解/55.1 二叉树的深度.html)
- [55.2 平衡二叉树](http://www.cyc2018.xyz/算法/剑指 Offer 题解/55.2 平衡二叉树.html)
- [68. 树中两个节点的最低公共祖先](http://www.cyc2018.xyz/算法/剑指 Offer 题解/68. 树中两个节点的最低公共祖先.html)

## [#](http://www.cyc2018.xyz/算法/剑指 Offer 题解/剑指 Offer 题解 - 目录.html#贪心思想)贪心思想

- [14. 剪绳子](http://www.cyc2018.xyz/算法/剑指 Offer 题解/14. 剪绳子.html)
- [63. 股票的最大利润](http://www.cyc2018.xyz/算法/剑指 Offer 题解/63. 股票的最大利润.html)

## [#](http://www.cyc2018.xyz/算法/剑指 Offer 题解/剑指 Offer 题解 - 目录.html#二分查找)二分查找

- [11. 旋转数组的最小数字](http://www.cyc2018.xyz/算法/剑指 Offer 题解/11. 旋转数组的最小数字.html)
- [53. 数字在排序数组中出现的次数](http://www.cyc2018.xyz/算法/剑指 Offer 题解/53. 数字在排序数组中出现的次数.html)

## [#](http://www.cyc2018.xyz/算法/剑指 Offer 题解/剑指 Offer 题解 - 目录.html#分治)分治

- [16. 数值的整数次方](http://www.cyc2018.xyz/算法/剑指 Offer 题解/16. 数值的整数次方.html)

## [#](http://www.cyc2018.xyz/算法/剑指 Offer 题解/剑指 Offer 题解 - 目录.html#搜索)搜索

- [12. 矩阵中的路径](http://www.cyc2018.xyz/算法/剑指 Offer 题解/12. 矩阵中的路径.html)
- [13. 机器人的运动范围](http://www.cyc2018.xyz/算法/剑指 Offer 题解/13. 机器人的运动范围.html)
- [38. 字符串的排列](http://www.cyc2018.xyz/算法/剑指 Offer 题解/38. 字符串的排列.html)

## [#](http://www.cyc2018.xyz/算法/剑指 Offer 题解/剑指 Offer 题解 - 目录.html#排序)排序

- [21. 调整数组顺序使奇数位于偶数前面](http://www.cyc2018.xyz/算法/剑指 Offer 题解/21. 调整数组顺序使奇数位于偶数前面.html)
- [45. 把数组排成最小的数](http://www.cyc2018.xyz/算法/剑指 Offer 题解/45. 把数组排成最小的数.html)
- [51. 数组中的逆序对](http://www.cyc2018.xyz/算法/剑指 Offer 题解/51. 数组中的逆序对.html)

## [#](http://www.cyc2018.xyz/算法/剑指 Offer 题解/剑指 Offer 题解 - 目录.html#动态规划)动态规划

- [10.1 斐波那契数列](http://www.cyc2018.xyz/算法/剑指 Offer 题解/10.1 斐波那契数列.html)
- [10.2 矩形覆盖](http://www.cyc2018.xyz/算法/剑指 Offer 题解/10.2 矩形覆盖.html)
- [10.3 跳台阶](http://www.cyc2018.xyz/算法/剑指 Offer 题解/10.3 跳台阶.html)
- [10.4 变态跳台阶](http://www.cyc2018.xyz/算法/剑指 Offer 题解/10.4 变态跳台阶.html)
- [42. 连续子数组的最大和](http://www.cyc2018.xyz/算法/剑指 Offer 题解/42. 连续子数组的最大和.html)
- [47. 礼物的最大价值](http://www.cyc2018.xyz/算法/剑指 Offer 题解/47. 礼物的最大价值.html)
- [48. 最长不含重复字符的子字符串](http://www.cyc2018.xyz/算法/剑指 Offer 题解/48. 最长不含重复字符的子字符串.html)
- [49. 丑数](http://www.cyc2018.xyz/算法/剑指 Offer 题解/49. 丑数.html)
- [60. n 个骰子的点数](http://www.cyc2018.xyz/算法/剑指 Offer 题解/60. n 个骰子的点数.html)
- [66. 构建乘积数组](http://www.cyc2018.xyz/算法/剑指 Offer 题解/66. 构建乘积数组.html)

## [#](http://www.cyc2018.xyz/算法/剑指 Offer 题解/剑指 Offer 题解 - 目录.html#数学)数学

- [39. 数组中出现次数超过一半的数字](http://www.cyc2018.xyz/算法/剑指 Offer 题解/39. 数组中出现次数超过一半的数字.html)
- [62. 圆圈中最后剩下的数](http://www.cyc2018.xyz/算法/剑指 Offer 题解/62. 圆圈中最后剩下的数.html)
- [43. 从 1 到 n 整数中 1 出现的次数](http://www.cyc2018.xyz/算法/剑指 Offer 题解/43. 从 1 到 n 整数中 1 出现的次数.html)

## [#](http://www.cyc2018.xyz/算法/剑指 Offer 题解/剑指 Offer 题解 - 目录.html#位运算)位运算

- [15. 二进制中 1 的个数](http://www.cyc2018.xyz/算法/剑指 Offer 题解/15. 二进制中 1 的个数.html)
- [56. 数组中只出现一次的数字](http://www.cyc2018.xyz/算法/剑指 Offer 题解/56. 数组中只出现一次的数字.html)

## [#](http://www.cyc2018.xyz/算法/剑指 Offer 题解/剑指 Offer 题解 - 目录.html#其它)其它

- [17. 打印从 1 到最大的 n 位数](http://www.cyc2018.xyz/算法/剑指 Offer 题解/17. 打印从 1 到最大的 n 位数.html)
- [19. 正则表达式匹配](http://www.cyc2018.xyz/算法/剑指 Offer 题解/19. 正则表达式匹配.html)
- [20. 表示数值的字符串](http://www.cyc2018.xyz/算法/剑指 Offer 题解/20. 表示数值的字符串.html)
- [44. 数字序列中的某一位数字](http://www.cyc2018.xyz/算法/剑指 Offer 题解/44. 数字序列中的某一位数字.html)
- [46. 把数字翻译成字符串](http://www.cyc2018.xyz/算法/剑指 Offer 题解/46. 把数字翻译成字符串.html)
- [61. 扑克牌顺子](http://www.cyc2018.xyz/算法/剑指 Offer 题解/61. 扑克牌顺子.html)
- [64. 求 1+2+3+...+n](http://www.cyc2018.xyz/算法/剑指 Offer 题解/64. 求 1+2+3+...+n.html)
- [65. 不用加减乘除做加法](http://www.cyc2018.xyz/算法/剑指 Offer 题解/65. 不用加减乘除做加法.html)
- [67. 把字符串转换成整数](http://www.cyc2018.xyz/算法/剑指 Offer 题解/67. 把字符串转换成整数.html)

## 替换空格

使用从尾到头遍历数组形式修改数组：

1. 使用Java本身的`API`
   - `str.charAt(index)`
   - `str.replace(index,index+1,”%20")`
2. 辅助数组
   - 遍历得到blankCount 得到辅助数组dest的长度
   - `for(int i=source.length-1,j=dest.length-1;i>=0&&j>=0;i—,j—)`
3. 原地 从尾到头 
   - `str.setLength(newIndex+1);`





## 34 二叉树中路径值和

#### 题目描述

输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下**一直到叶结点**所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)

```java
public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) {
        
}
```



#### 解析

审题可知，我们需要有一个自上而下从根结点到每个叶子结点的遍历思路，而先序遍历刚好可以拿来用，我们只需在来到当前结点时将当前结点值加入到栈中，在离开当前结点时再将栈中保存的当前结点的值弹出即可使用栈模拟保存自上而下经过的结点，从而实现在来到每个叶子结点时只需判断栈中数值之和是否为`target`即可。



```java
public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) {
    ArrayList<ArrayList<Integer>> res = new ArrayList();
    if(root == null){
        return res;
    }
    Stack<Integer> stack = new Stack<Integer>();
    preOrder(root, stack, 0, target, res);
    return res;
}

public void preOrder(TreeNode root, Stack<Integer> stack, int sum, int target, 
                     ArrayList<ArrayList<Integer>> res){
    if(root == null){
        return;
    }

    stack.push(root.val);
    sum += root.val;
    //leaf node
    if(root.left == null && root.right == null && sum == target){
        ArrayList<Integer> one = new ArrayList();
        one.addAll(stack);
        res.add(one);
    }

    preOrder(root.left, stack, sum, target, res);
    preOrder(root.right, stack, sum, target, res);

    sum -= stack.pop();
}
```



```java
private static ArrayList<ArrayList<Integer>> ret = new ArrayList<>();
public static ArrayList<ArrayList<Integer>> FindPath02(TreeNode root, int target) {
    backtracking(root, target,new ArrayList<>());
    return ret;
}

private static void backtracking(TreeNode node, int target, ArrayList<Integer> path) {
    if (node==null) {
        return;
    }
    path.add(node.val);
    target-= node.val;
    if (target==0&&node.left==null&&node.right==null) {
        ret.add(new ArrayList<>(path));

    }else {
        backtracking(node.left,target,path);
        backtracking(node.right,target,path);
    }
    path.remove(path.size()-1);
}
```





## 搜索二叉树转化为有序双向链表

搜索二叉树的中序遍历为有序

transform作为黑盒转化 

找到root结点的最左侧作为链表头  

root结点的左子树的最右节点和root结点的右子树的最左结点分别作为root的前驱和后继链表节点

``` java
public TreeNode Convert(TreeNode root) {
    if(root == null){
        return null;
    }

    //head is the most left node
    TreeNode head = root;
    while(head.left != null){
        head = head.left;
    }
    transform(root);
    return head;
}

//transform a tree to a double-link list
public void transform(TreeNode root){
    if(root == null){
        return;
    }
    TreeNode pre = root.left, next = root.right;
    while(pre != null && pre.right != null){
        pre = pre.right;
    }
    while(next != null && next.left != null){
        next = next.left;
    }

    transform(root.left);
    transform(root.right);
    //asume the left and right has transformed and what's remaining is link the root
    root.left = pre;
    if(pre != null){
        pre.right = root;
    }
    root.right = next;
    if(next != null){
        next.left = root;
    }
}
```



## 41.2 字符流中第一个非重复字符

### 题目描述

请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 "go" 时，第一个只出现一次的字符是 "g"。当从该字符流中读出前六个字符“google" 时，第一个只出现一次的字符是 "l"。

### 解题思路

使用统计数组来统计每个字符出现的次数，本题涉及到的字符为都为 ASCII 码，因此使用一个大小为 128 的整型数组就能完成次数统计任务。

使用队列来存储到达的字符，并在每次有新的字符从字符流到达时移除队列头部那些出现次数不再是一次的元素。因为队列是先进先出顺序，因此队列头部的元素为第一次只出现一次的字符。

### 注意事项⚠️

将字符流逐个入队并判断队首字符出现次数是否超过一次 是则剔除

```java
private int[]cnts=new int[128];
private Queue<Character> queue=new LinkedList>();

public void Insert(char ch){
        cnts[ch]++;
        queue.add(ch);
        while(!queue.isEmpty()&&cnts[queue.peek()]>1)
        queue.poll();
        }

public char FirstAppearingOnce(){
        return queue.isEmpty()?'#':queue.peek();
        }
```

## 59. 滑动窗口的最大值

### 题目描述

给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。

### 解题思路

- 维护一个大小为窗口大小的大顶堆，顶堆元素则为当前窗口的最大值。
- 使用一个双端队列，保证队首存放的是窗口最大值的下标。遍历数组，
    - 队尾元素比要入队的元素小，则把其移除（因为不可能成为窗口最大值）。
    - 队首下标对应的元素不在窗口内（即窗口最大值），将其从队列中移除。
    - 把每次滑动值的下标加入队列中（经过步骤1、2，此时加入队列的下标要么是当前窗口最大值的下标，要么是小于窗口最大值的下标）。
    - 滑动窗口的首地址i大于size就写入窗口最大值。

### 注意事项⚠️

- 大根堆 O(NlogM) n为数组长 m为窗口长度

    - 先将第一个窗口入堆并存下最大值堆顶;
    - 再从`i=0,j=i+size;j<nums.length;i++,j++` 逐个滑动清除出窗数据再读入入窗数据并添加堆顶元素

    ```java
        public static ArrayList<Integer> maxInWidows(int[] nums, int size) {
            ArrayList<Integer> ret = new ArrayList<>();
            if(size>nums.length||size<1) {
                return ret;
            }
            PriorityQueue<Integer> heap = new PriorityQueue<>(Comparator.reverseOrder());
            // 将第一个窗口入堆
            for (int i = 0; i < size; i++) {
                heap.add(nums[i]);
            }
    
            // 存下第一个窗口的堆内的最大值
            ret.add(heap.peek());
            for(int i=0,j=i+size;j<nums.length;i++,j++) {
                // 删除窗口滑动中出窗的数
                heap.remove(nums[i]);
                heap.add(nums[j]);
                ret.add(heap.peek());
            }
            return ret;
        }
    ```

- 双端队列

    ```java
    // 双端队列
        public static ArrayList<Integer> maxInWindows02(int[] nums, int size) {
            ArrayList<Integer> reList = new ArrayList<>();
            if(nums==null||nums.length<size||size<1) {
                return reList;
            }
            Deque<Integer> deque = new LinkedList<>();
            for (int i = 0; i < nums.length; i++) {
                // 队尾元素小于入队元素 则移除
                while (!deque.isEmpty()&&nums[deque.getLast()]<=nums[i]) {
                    deque.pollLast();
                }
                // 队首下标对应的元素不在窗口内即剔除
                while (!deque.isEmpty()&&(i-deque.getFirst()+1>size)) {
                    deque.pollFirst();
                }
                // 每次滑动的值加入队列
                deque.add(i);
                // 滑动窗口的首地址i大于size就写入窗口
                if(!deque.isEmpty()&&i+1>=size) {
                    reList.add(nums[deque.getFirst()]);
                }
            }
            return reList;
            
        }
    ```

    